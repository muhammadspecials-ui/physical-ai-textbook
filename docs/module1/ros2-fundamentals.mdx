---
sidebar_position: 1
---



# Module 1: The Robotic Nervous System (ROS 2)



## Introduction to ROS 2

ROS 2 (Robot Operating System 2) is the middleware that serves as the nervous system of modern robots. Just as your nervous system coordinates communication between your brain and body, ROS 2 coordinates communication between different parts of a robot.

## Why ROS 2?

ROS 2 is the industry standard for robotic development because it provides:

- **Modularity**: Break complex systems into manageable components
- **Scalability**: From simple robots to complex multi-robot systems
- **Real-time Performance**: Critical for responsive robotic control
- **Security**: Built-in DDS (Data Distribution Service) security
- **Cross-platform**: Works on Linux, Windows, and macOS

## Core Concepts

### 1. Nodes

Nodes are the fundamental building blocks of ROS 2. Each node is a process that performs a specific task.

**Example**: A robot might have separate nodes for:
- Camera processing
- Motor control
- Path planning
- Object detection

```python
import rclpy
from rclpy.node import Node

class MinimalNode(Node):
    def __init__(self):
        super().__init__('minimal_node')
        self.get_logger().info('Hello from ROS 2!')

def main(args=None):
    rclpy.init(args=args)
    node = MinimalNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 2. Topics

Topics enable publish-subscribe communication between nodes. One node publishes data, and multiple nodes can subscribe to receive it.

**Example**: A camera node publishes images, while object detection and display nodes subscribe to those images.

```python
from sensor_msgs.msg import Image

class ImagePublisher(Node):
    def __init__(self):
        super().__init__('image_publisher')
        self.publisher = self.create_publisher(Image, 'camera/image', 10)
        self.timer = self.create_timer(0.1, self.publish_image)
    
    def publish_image(self):
        msg = Image()
        # Fill image data
        self.publisher.publish(msg)
        self.get_logger().info('Publishing image')
```

### 3. Services

Services provide request-response communication. Unlike topics, services are synchronous and bidirectional.

**Example**: A node requests the robot to move to a specific position and waits for confirmation.

```python
from example_interfaces.srv import AddTwoInts

class ServiceServer(Node):
    def __init__(self):
        super().__init__('service_server')
        self.srv = self.create_service(
            AddTwoInts, 
            'add_two_ints', 
            self.add_callback
        )
    
    def add_callback(self, request, response):
        response.sum = request.a + request.b
        return response
```

### 4. Actions

Actions are for long-running tasks that need feedback. They combine the best of topics and services.

**Example**: Moving a robot arm to a position while receiving progress updates.

## URDF: Robot Description

URDF (Unified Robot Description Format) is XML-based format for describing robot structure.

```xml
<?xml version="1.0"?>
<robot name="simple_robot">
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.6 0.4 0.2"/>
      </geometry>
    </visual>
  </link>
  
  <link name="wheel_left">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </visual>
  </link>
  
  <joint name="base_to_wheel_left" type="continuous">
    <parent link="base_link"/>
    <child link="wheel_left"/>
    <origin xyz="0 0.2 0"/>
    <axis xyz="0 1 0"/>
  </joint>
</robot>
```

## Bridging Python AI to ROS 2

One of ROS 2's superpowers is integrating AI models with robotic control.

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import String
import cv2
from cv_bridge import CvBridge

class ObjectDetector(Node):
    def __init__(self):
        super().__init__('object_detector')
        self.subscription = self.create_subscription(
            Image,
            'camera/image',
            self.image_callback,
            10
        )
        self.publisher = self.create_publisher(String, 'detected_objects', 10)
        self.bridge = CvBridge()
    
    def image_callback(self, msg):
        # Convert ROS Image to OpenCV
        cv_image = self.bridge.imgmsg_to_cv2(msg, 'bgr8')
        
        # Run AI model (simplified)
        detected = self.detect_objects(cv_image)
        
        # Publish results
        result_msg = String()
        result_msg.data = f"Detected: {detected}"
        self.publisher.publish(result_msg)
    
    def detect_objects(self, image):
        # Your AI model here
        return "cup, bottle"
```

## Practical Exercise

**Build a Simple Robot Controller**

Create a node that:
1. Subscribes to sensor data
2. Processes the data
3. Publishes motor commands

This forms the basic loop of robotic control!

## Key Takeaways

- ROS 2 is the nervous system of robots
- Nodes are independent processes that communicate
- Topics enable asynchronous data streaming
- Services provide request-response patterns
- URDF describes robot physical structure
- Python + ROS 2 = Powerful AI-enabled robotics

## Next Steps

In Module 2, we'll take these concepts into simulation, creating digital twins of robots in Gazebo and Unity!
